#!/bin/bash

# Configuration management library for Greenplum Installer
# Provides configuration handling and user interaction

source "$(dirname "${BASH_SOURCE[0]}")/logging.sh"
source "$(dirname "${BASH_SOURCE[0]}")/validation.sh"

# Default configuration values
DEFAULT_INSTALL_DIR="/usr/local/greenplum-db"
DEFAULT_DATA_ROOT="/data"
DEFAULT_CONFIG_FILE="gpdb_config.conf"

# Function to load configuration from file
load_configuration() {
    local config_file="${1:-$DEFAULT_CONFIG_FILE}"
    
    if [ -f "$config_file" ]; then
        log_info "Loading configuration from '$config_file'..."
        source "$config_file"
        
        # Explicitly export configuration variables
        export GPDB_COORDINATOR_HOST
        export GPDB_STANDBY_HOST  
        export GPDB_SEGMENT_HOSTS
        export GPDB_INSTALL_DIR
        export GPDB_DATA_ROOT
        export GPADMIN_PASSWORD
        
        # Derive specific directory paths from root
        export COORDINATOR_DATA_DIR="$GPDB_DATA_ROOT/coordinator"
        export SEGMENT_DATA_DIR="$GPDB_DATA_ROOT/primary"
        export MIRROR_DATA_DIR="$GPDB_DATA_ROOT/mirror"
        
        validate_configuration
        log_success "Configuration loaded successfully"
        return 0
    else
        log_warn "Configuration file '$config_file' not found"
        return 1
    fi
}

# Function to save configuration to file
save_configuration() {
    local config_file="${1:-$DEFAULT_CONFIG_FILE}"
    
    log_info "Saving configuration to '$config_file'..."
    
    cat > "$config_file" << EOL
# Greenplum Database Installation Configuration
# This file is auto-generated by the installer script.
# Generated on: $(date)

GPDB_COORDINATOR_HOST="$GPDB_COORDINATOR_HOST"
GPDB_STANDBY_HOST="$GPDB_STANDBY_HOST"
GPDB_SEGMENT_HOSTS=($(echo "${GPDB_SEGMENT_HOSTS[@]}" | tr ' ' ' '))
GPDB_INSTALL_DIR="$GPDB_INSTALL_DIR"
GPDB_DATA_ROOT="$GPDB_DATA_ROOT"

# Security credentials (stored securely)
GPADMIN_PASSWORD="$GPADMIN_PASSWORD"
EOL
    
    log_success "Configuration saved to '$config_file'"
}

# Function to prompt user for configuration
prompt_for_configuration() {
    log_info "Configuring Greenplum installation..."
    
    # Coordinator hostname
    local default_coordinator=$(hostname)
    read -p "Enter the coordinator hostname [$default_coordinator]: " input_coordinator
    GPDB_COORDINATOR_HOST=${input_coordinator:-$default_coordinator}
    validate_hostname "$GPDB_COORDINATOR_HOST"
    
    # Segment hosts
    read -p "Enter all segment hostnames (comma-separated) [$GPDB_COORDINATOR_HOST]: " input_segments
    local segments_input=${input_segments:-$GPDB_COORDINATOR_HOST}
    
    # Convert comma-separated string to array
    IFS=',' read -ra GPDB_SEGMENT_HOSTS <<< "$segments_input"
    
    # Trim whitespace from each hostname
    for i in "${!GPDB_SEGMENT_HOSTS[@]}"; do
        GPDB_SEGMENT_HOSTS[$i]=$(echo "${GPDB_SEGMENT_HOSTS[$i]}" | xargs)
        validate_hostname "${GPDB_SEGMENT_HOSTS[$i]}"
    done
    
    # Check if single-node installation
    if [ ${#GPDB_SEGMENT_HOSTS[@]} -eq 1 ] && [ "${GPDB_SEGMENT_HOSTS[0]}" = "$GPDB_COORDINATOR_HOST" ]; then
        log_info "Single-node installation detected"
    fi
    
    # Standby coordinator
    read -p "Do you want to set up a standby coordinator? (y/n) [n]: " setup_standby
    setup_standby=${setup_standby:-n}
    
    GPDB_STANDBY_HOST=""
    if [[ "$setup_standby" =~ ^[Yy]$ ]]; then
        read -p "Enter the standby coordinator hostname: " input_standby
        if [ -n "$input_standby" ]; then
            GPDB_STANDBY_HOST="$input_standby"
            validate_hostname "$GPDB_STANDBY_HOST"
        else
            log_error "Standby coordinator hostname cannot be empty"
        fi
    fi
    
    # Installation directory
    read -p "Enter the Greenplum installation directory [$DEFAULT_INSTALL_DIR]: " input_install_dir
    GPDB_INSTALL_DIR=${input_install_dir:-$DEFAULT_INSTALL_DIR}
    validate_directory_path "$GPDB_INSTALL_DIR" "installation"
    
    # Data root directory
    read -p "Enter the data root directory [$DEFAULT_DATA_ROOT]: " input_data_root
    GPDB_DATA_ROOT=${input_data_root:-$DEFAULT_DATA_ROOT}
    validate_directory_path "$GPDB_DATA_ROOT" "data root"
    
    log_info "Directory structure will be:"
    log_info "  Coordinator data: $GPDB_DATA_ROOT/coordinator"
    log_info "  Primary segments: $GPDB_DATA_ROOT/primary"
    log_info "  Mirror segments:  $GPDB_DATA_ROOT/mirror"
    
    # Gpadmin password
    echo ""
    log_info "The installer will create a 'gpadmin' user for Greenplum administration."
    read -s -p "Enter password for gpadmin user: " GPADMIN_PASSWORD
    echo ""
    if [ -z "$GPADMIN_PASSWORD" ]; then
        log_error "Gpadmin password cannot be empty"
        return 1
    fi
    
    # Validate password strength
    validate_password "$GPADMIN_PASSWORD" "gpadmin"
    
    # Validate complete configuration
    validate_configuration
    
    log_success "Configuration completed successfully"
}

# Function to display current configuration
show_configuration() {
    echo ""
    echo "Current Configuration:"
    echo "====================="
    echo "Coordinator Host: $GPDB_COORDINATOR_HOST"
    echo "Segment Hosts: ${GPDB_SEGMENT_HOSTS[*]}"
    echo "Standby Host: ${GPDB_STANDBY_HOST:-None}"
    echo "Install Directory: $GPDB_INSTALL_DIR"
    echo "Data Root Directory: $GPDB_DATA_ROOT"
    echo "  └─ Coordinator: $GPDB_DATA_ROOT/coordinator"
    echo "  └─ Segments: $GPDB_DATA_ROOT/primary"
    echo "  └─ Mirrors: $GPDB_DATA_ROOT/mirror"
    echo "Gpadmin Password: ${GPADMIN_PASSWORD:+[Configured]}"
    echo "====================="
    echo ""
}

# Function to configure installation interactively
configure_installation() {
    local config_file="${1:-$DEFAULT_CONFIG_FILE}"
    local template_file="${config_file}.template"
    
    log_info "Starting configuration..."
    
    # Check for existing configuration
    if [ -f "$config_file" ]; then
        log_info "Configuration file '$config_file' found."
        load_configuration "$config_file"
        show_configuration
        
        read -p "Do you want to use the existing configuration? (y/n) [y]: " use_existing
        use_existing=${use_existing:-y}
        
        if [[ "$use_existing" =~ ^[Yy]$ ]]; then
            log_success "Using existing configuration"
            return 0
        fi
    else
        # Check if template exists and offer to copy it
        if [ -f "$template_file" ]; then
            log_info "Configuration template found: $template_file"
            echo ""
            log_info "Options:"
            echo "  1. Copy template and customize interactively"
            echo "  2. Copy template as-is (edit manually later)"
            echo "  3. Create new configuration interactively"
            echo ""
            read -p "Choose option (1-3) [1]: " template_option
            template_option=${template_option:-1}
            
            case "$template_option" in
                1)
                    log_info "Copying template and starting interactive configuration..."
                    cp "$template_file" "$config_file"
                    ;;
                2)
                    log_info "Copying template as-is..."
                    cp "$template_file" "$config_file"
                    log_success "Configuration template copied to '$config_file'"
                    log_info "Please edit '$config_file' with your actual values and re-run the installer"
                    return 1
                    ;;
                3)
                    log_info "Creating new configuration interactively..."
                    ;;
                *)
                    log_warn "Invalid option. Creating new configuration interactively..."
                    ;;
            esac
        fi
    fi
    
    # Prompt for new configuration
    log_info "Setting up new configuration..."
    prompt_for_configuration
    
    # Save configuration
    save_configuration "$config_file"
    
    # Display final configuration
    show_configuration
    
    # Confirm configuration
    read -p "Is this configuration correct? (y/n) [y]: " confirm_config
    confirm_config=${confirm_config:-y}
    
    if [[ ! "$confirm_config" =~ ^[Yy]$ ]]; then
        log_info "Reconfiguring..."
        configure_installation "$config_file"
    fi
}

# Function to get all unique hosts from configuration
get_all_hosts() {
    local all_hosts_with_dupes=("$GPDB_COORDINATOR_HOST" "${GPDB_SEGMENT_HOSTS[@]}")
    
    if [ -n "$GPDB_STANDBY_HOST" ]; then
        all_hosts_with_dupes+=("$GPDB_STANDBY_HOST")
    fi
    
    # Return unique, sorted list of hosts
    echo "${all_hosts_with_dupes[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '
}

# Function to check if configuration is for single-node
is_single_node_installation() {
    local all_hosts=($(get_all_hosts))
    
    if [ ${#all_hosts[@]} -eq 1 ] && [ "${all_hosts[0]}" = "$GPDB_COORDINATOR_HOST" ]; then
        return 0
    else
        return 1
    fi
}

# Function to validate configuration completeness
validate_configuration_completeness() {
    local errors=()
    
    [ -z "$GPDB_COORDINATOR_HOST" ] && errors+=("Coordinator host not set")
    [ ${#GPDB_SEGMENT_HOSTS[@]} -eq 0 ] && errors+=("No segment hosts defined")
    [ -z "$GPDB_INSTALL_DIR" ] && errors+=("Install directory not set")
    [ -z "$GPDB_DATA_ROOT" ] && errors+=("Data root directory not set")
    
    if [ ${#errors[@]} -gt 0 ]; then
        log_error "Configuration validation failed: ${errors[*]}"
        return 1
    fi
    
    return 0
}

# Function to export configuration as environment variables
export_configuration() {
    export GPDB_COORDINATOR_HOST
    export GPDB_STANDBY_HOST
    export GPDB_SEGMENT_HOSTS
    export GPDB_INSTALL_DIR
    export GPDB_DATA_DIR
}

# Function to reset configuration to defaults
reset_configuration() {
    GPDB_COORDINATOR_HOST=""
    GPDB_STANDBY_HOST=""
    GPDB_SEGMENT_HOSTS=()
    GPDB_INSTALL_DIR="$DEFAULT_INSTALL_DIR"
    GPDB_DATA_ROOT="$DEFAULT_DATA_ROOT"
}